#!/usr/bin/env python3
import yaml
import requests
import argparse
import sys
import os
from urllib.parse import urlparse

# helper for grabbing yaml from a url
def fetch_from_url(url):
    """
    Fetches content from a URL. It's smart enough to convert a typical
    GitHub "view file" link into the "raw content" link, which is what we need.
    """
    # github links need to be raw
    if "github.com" in url and "/blob/" in url:
        print("github link detected, switching to raw...", file=sys.stderr)
        url = url.replace("github.com", "raw.githubusercontent.com").replace("/blob/", "/")
        print(f"new url: {url}", file=sys.stderr)

    try:
        response = requests.get(url)
        response.raise_for_status() # errors out on 404s etc
        return response.text
    except requests.exceptions.RequestException as e:
        print(f"couldn't fetch url {url}. error: {e}", file=sys.stderr)
        sys.exit(1)

# simple file reader
def read_from_file(filepath):
    """Reads content from a local file path."""
    try:
        with open(filepath, 'r') as f:
            return f.read()
    except IOError as e:
        print(f"couldn't read file {filepath}. error: {e}", file=sys.stderr)
        sys.exit(1)

# handle C string escapes
def escape_c_string(s):
    """Escapes characters like quotes and backslashes for a C string literal."""
    if not s:
        return ""
    # double backslashes are important
    return s.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n')

# main parsing logic. the db has a few yaml formats, this handles them.
def parse_instructions(yaml_data, source_identifier):
    """
    Turns the raw YAML data into a clean list of instructions.
    It checks for a few different formats we expect to see.
    """
    instructions = []

    # format 1: single instruction file (like add.yaml)
    # these files don't name the instruction, so we guess from the filename
    if isinstance(yaml_data, dict) and 'isa' in yaml_data and 'encoding' in yaml_data:
        print("looks like a single-instruction file.", file=sys.stderr)
        path = urlparse(source_identifier).path
        name = os.path.splitext(os.path.basename(path))[0] # e.g., 'add.yaml' -> 'add'

        instructions.append({
            'name': name,
            'isa': yaml_data.get('isa', 'N/A'),
            'description': yaml_data.get('description', 'No description.'),
            'encoding': yaml_data.get('encoding', 'N/A'),
            'extension': (yaml_data.get('extension') or ['N/A'])[0] if isinstance(yaml_data.get('extension'), list) else yaml_data.get('extension', 'N/A'),
        })

    # format 2: the standard multi-instruction dict from the DB
    elif isinstance(yaml_data, dict):
        print("looks like a multi-instruction dictionary.", file=sys.stderr)
        for name, properties in yaml_data.items():
            if not isinstance(properties, dict): continue # skip metadata
            instructions.append({
                'name': name,
                'isa': properties.get('isa', 'N/A'),
                'description': properties.get('description', 'No description.'),
                'encoding': (properties.get('encoding') or ['N/A'])[0] if isinstance(properties.get('encoding'), list) else properties.get('encoding', 'N/A'),
                'extension': (properties.get('extension') or ['N/A'])[0] if isinstance(properties.get('extension'), list) else properties.get('extension', 'N/A'),
            })

    # format 3: the list our C program makes
    # for the second round trip
    elif isinstance(yaml_data, list):
        print("looks like the list format from a previous run.", file=sys.stderr)
        for item in yaml_data:
            if not isinstance(item, dict): continue
            instructions.append({
                'name': item.get('name', 'N/A'),
                'isa': item.get('isa', 'N/A'),
                'description': item.get('description', 'No description.'),
                'encoding': item.get('encoding', 'N/A'),
                'extension': item.get('extension', 'N/A'),
            })
    return instructions

# writes the C header
def generate_c_header(instructions, output_path):
    """Generates the riscv_inst.h file from our list of instructions."""
    try:
        with open(output_path, 'w') as f:
            f.write("/*\n * auto-generated by yaml_to_c.py\n * don't edit directly.\n */\n")
            f.write("#ifndef RISCV_INST_H\n")
            f.write("#define RISCV_INST_H\n\n")

            # define the C struct
            f.write("typedef struct {\n")
            f.write("    const char* name;\n")
            f.write("    const char* isa;\n")
            f.write("    const char* description;\n")
            f.write("    const char* encoding;\n")
            f.write("    const char* extension;\n")
            f.write("} RiscVInstruction;\n\n")

            # create the big static array of instructions
            # static const is good practice here
            f.write("static const RiscVInstruction riscv_instructions[] = {\n")
            for inst in instructions:
                f.write("    {\n")
                f.write(f'        .name = "{escape_c_string(inst["name"])}",\n')
                f.write(f'        .isa = "{escape_c_string(inst["isa"])}",\n')
                f.write(f'        .description = "{escape_c_string(inst["description"])}",\n')
                f.write(f'        .encoding = "{escape_c_string(inst["encoding"])}",\n')
                f.write(f'        .extension = "{escape_c_string(inst["extension"])}"\n')
                f.write("    },\n")
            f.write("};\n\n")

            # also nice to have the instruction count
            f.write(f"static const int riscv_instruction_count = {len(instructions)};\n\n")

            f.write("#endif /* RISCV_INST_H */\n")
        print(f"Success! C header is ready at {output_path}")
    except IOError as e:
        print(f"Ugh, couldn't write the header file. Error: {e}", file=sys.stderr)
        sys.exit(1)

def main():
    """The main entry point of the script."""
    parser = argparse.ArgumentParser(
        description="A script to turn RISC-V instruction YAML into a C header."
    )
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--url', help='URL of the YAML file to process.')
    group.add_argument('--file', help='Local path of the YAML file to process.')
    parser.add_argument('--output', required=True, help='Where to save the C header file.')

    args = parser.parse_args()
    source_identifier = args.url if args.url else args.file

    # get yaml from web or local file
    if args.url:
        yaml_content = fetch_from_url(args.url)
    else:
        yaml_content = read_from_file(args.file)

    # try to parse it
    try:
        data = yaml.safe_load(yaml_content)
    except yaml.YAMLError as e:
        print(f"The YAML from {source_identifier} seems broken. Error: {e}", file=sys.stderr)
        sys.exit(1)

    # turn it into our standard format
    instructions = parse_instructions(data, source_identifier)
    if not instructions:
        print(f"Couldn't find any instructions in {source_identifier}. Something's wrong.", file=sys.stderr)
        sys.exit(1)

    # write the C header
    generate_c_header(instructions, args.output)

if __name__ == "__main__":
    main()
